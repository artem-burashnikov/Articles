% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Детали реализации}
\subsection{GraphBlas}
Обход в ширину был реализован на языке \texttt{F\#} с использованием идей, заложенных GraphBlas.

\textit{GraphBlas} - это инициатива, нацеленная на создание стандартизованного интерфейса для разработки графовых алгоритмов. Целью этой инициативы является обеспечение высокой производительности и переносимости для широкого спектра алгоритмов, работающих с различными графовыми структурами.

Пользователю предоставляется языково-независимая спецификация, определяющая набор абстрактных операций линейной алгебры: умножение матрицы на вектор, сложение векторов и умножение матрицы на матрицу. Описанная семантика и требования для интерфейса позволяют создавать собственные реализации на различных языках программирования и для различных аппаратных платформ. 

\subsection{Концепция алгоритма}
Основной принцип состоит в том, что применение операции умножения вектора на матрицу, определенной в GraphBlas, является переходом от одних вершин графа к другим по инцидентным этим вершинам рёбрам.
В свою очередь вектора представлены в виде двоичного дерева, а матрицы --- в виде дерева квадрантов. Такое представление удобно не только для хранения разреженных структур в памяти, но и для внедрения параллелизма. Рассмотрим конкретные шаги алгоритма:
\begin{itemize}
    \item \textbf{Шаг 1} Создается матрица смежности, соответствующая данному графу. В нашем случае по матрице смежности, представленной как список координат, строится дерево квадрантов. Причем использование \texttt{F\#} позволяет естественно выражать отсутствующие рёбра и отсутствующие метки через тип \textbf{Option}. Значения в ячейках матрицы заполняются значениями на соответствующих рёбрах графа.
    \item \textbf{Шаг 2} Задаются два вектора:
    \begin{enumerate}
        \item Фронт: вектор, в котором каждый индекс соответствует вершине графа, а значения указывают на текущие просматриваемые вершины. Отсутствие вершины в текущем фронте обозначается как \textbf{Option None}.
        \item Результирующий вектор, который при инициализации совпадает с фронтом, аккумулирует промежуточные результаты работы алгоритма (например, минимальный путь).
    \end{enumerate}
    \item \textbf{Шаг 3} Выполняется умножение вектора состояний на матрицу смежности. В качестве поэлементных операций сложения и умножения используются логические \textbf{ИЛИ} и \textbf{И}. После каждого умножения на результирующий вектор применяется маска, чтобы алгоритм не обрабатывал уже посещенные вершины. Результатом итерации является новый фронт и обновленный результирующий вектор.
\end{itemize}
Шаг 3 повторяется до тех пор, пока не будут достигнуты требуемые условия остановки. Например, все вершины станут исследованы или произойдет выполнение определенного условия.

\subsection{Параллелизм}
Благодаря рекуррентной природе деревьев, являющихся в нашем случае внутренним представлением векторов и матриц, реализованный алгоритм естественным образом поддаётся распараллеливанию. В листинге 1 представлен псевдокод с использованием абстрактных операций линейной алгебры. Минимальными единицами такой операции являются вектор размера \textbf{1\times2} и матрица размера \textbf{2\times2}, что на каждой итерации позволяет использовать до четырех потоков для разделения вычислений между ними.

\begin{center}
    \begin{tabular}{ccc}
        $\begin{bmatrix} a_{11} & a_{12} \end{bmatrix}$
        $\times$
        $\begin{bmatrix} b_{11} & b_{12} \\ b_{21} & b_{22} \end{bmatrix}$
        =
        $\begin{bmatrix} a_{11} \times b_{11} + a_{12} \times b_{21} \\ a_{11} \times b_{12} + a_{12} \times b_{22} \end{bmatrix}$
    \end{tabular}
\end{center}

\lstset{style=codelistingstyle}

\begin{algorithm}[ht]
\floatname{algorithm}{Листинг}
\caption{Псевдокод реализации параллельного алгоритма обхода в ширину}
\label{alg:bfs_example}
\begin{lstlisting}[language=pseudoFSharp]
def function BFS (parallelLevel, startingVertices, adjacencyMatrix):

    matrix := makeSparseMatrix from adjacencyMatrix
    
    frontier := makeSparseVector from startVertices
    
    result := makeSparseVector from startVertices

    def recursive function inner (frontier, result, counter):
        if frontier.IsEmpty then
            return result
        else
            newFrontier :=
                call multiplyVectorByMatrix (parallelLevel, frontier, matrix)
                
            newFrontier :=
                call applyMask (result, newFrontier)

            newResult :=
                call updateResult (count, result, newFrontier)

            newCounter := counter + 1
            
            call inner (newFrontier, newResult, newCounter)

    call inner (frontier, result, 1)
\end{lstlisting}
\end{algorithm}

Элементы матрицы --- поддеревья, поэтому вычисление элемента $a_{is} \times b_{sj}$ является рекурсивным вызовом на соответствующем поддереве. В представленной работе операция умножения над минимальными единицами разбивается на два потока: один из потоков отвечает за вычисление значения в первой строке результирующего вектора, а другой поток --- за вычисление значения во второй строке. При необходимости увеличить количество потоков на вход в BFS передаётся целый положительный параметр \textit{parallelLevel}, величина которого уменьшается с каждым вызовом тела функции, в результате чего производятся дополнительные асинхронные вычисления на следующем уровне рекурсии.