% !TeX spellcheck = ru_RU
% !TEX root = artem-burashnikov_parallel_bfs_experiments.tex

\section{Обзор предметной области}
\label{sec:relatedworks}
Для проведения эксперимента необходимо ознакомиться с существующими работами, затрагивающими проблемы многопоточной реализации BFS. Кроме того, требуется рассмотреть преимущества использования абстрактных операций линейной алгебры в алгоритме обхода в ширину, отметив выбор подходящей структуры данных для хранения матриц и векторов, а также обратить внимание на особенности выбранного для реализации языка программирования.

\subsection{Существующие исследования}
Алгоритм обхода графа в ширину ввиду своей прикладной значимости был проанализирован в различном контексте в ряде исследовательских работ. Некоторые из них рассмотрены далее.

В работе~\cite{adaptiveBFS} отмечается, что производительность BFS в значительной мере зависит от топологии подаваемого на вход графа. Ся Инлун (Xia Yinglong) и Празанна Виктор (Prasanna Viktor) показали, что в случае большого количества итераций алгоритма при малых количествах вершин/ребер между итерациями (то есть малом количестве вершин во фронте на каждой итерации) параллельная версия терпит снижение производительности из-за накладных расходов на создание параллельных задач.

Кроме того, в исследовании~\cite{scalableBFS} Вират Агарвал (Virat Agarwal) и другие продемонстрировали, что последовательная версия алгоритма в некоторых ситуациях оказывается предпочтительнее не оптимизированной параллельной ввиду большой задержки работы с памятью и высокой вычислительной стоимостью её синхронизации. 

Упомянутые авторы находят решение проблем оптимизации в тонкой настройке взаимодействия с общей памятью в используемой архитектуре или применении адаптивных алгоритмов, способных динамически контролировать количество используемых потоков во время исполнения.

Анализируя представленные работы, можно с высокой точностью прогнозировать зависимости между параметрами входных данных, выбранной архитектурой и ожидаемой производительностью используемой реализации обхода в ширину. Данное экспериментальное исследование будет посвящено выявлению таких зависимостей для алгоритма BFS, реализованного с применением методов линейной алгебры, что существенным образом влияет не только на сам алгоритм, но и на внутреннее представление графа в памяти компьютера, в связи с чем полученные результаты могут представлять особый интерес.

\subsection{Обход в ширину в контексте линейной алгебры}
Для эффективного представления и манипулирования графовыми структурами можно использовать матрицы и вектора. Рассмотрим теоретические основы такой  абстракции и её преимущества.

\subsubsection{GraphBlas}
Набор операций, которые могут быть применены к матрицам и векторам для выполнения различных графовых алгоритмов (таких как обходы, поиск путей, кластеризация и др.) заложен в \textit{GraphBlas}~\cite{gb_math}~\footnote{\href{https://graphblas.org/}{Форум, посвещенный стандарту GraphBlas. Дата посещения: 23.05.2023}}.

Это инициитива, нацеленная на создание стандартизованного интерфейса для разработки графовых алгоритмов. Её целью является обеспечение высокой производительности и переносимости для широкого спектра решений, работающих с различными графовыми структурами.

Пользователю предоставляется спецификация, определяющая абстрактное умножение матрицы на вектор, сложение векторов и умножение матрицы на матрицу. Описанная семантика и требования для интерфейса позволяют создавать собственные реализации на различных языках программирования и для различных аппаратных платформ. 

\subsection{Представление графа в памяти компьютера}
Нужно отметить, что реальные графы сильно разреженны, но в то же время обладают сравнительно большим количеством вершин.
Плотность графа (англ. --- \textit{density}) можно вычислить по формуле: 
\begin{equation}
\label{eq:density}
	\text{density} = \frac{2 \cdot |E|}{|V| \cdot (|V| - 1)},
\end{equation}
где $|E|$ --- {количество рёбер}, а $|V|$ --- количество вершин.\linebreak
Разреженными можно считать графы со значением плотности $<10\%$. В то время как на практике в основном встречаются сильно разреженные графы со значением density $<<<$ $2\%$. \newline
Хранить такие данные в виде двумерных таблиц не является эффективным решением, поэтому используют специальные структуры. Рассмотрим некоторые из них.
\begin{itemize}
	\item{\textbf{Список смежности}} \newline
	Это один из наиболее простых и эффективных способов хранения разреженных графов. Для каждой вершины выделяется список ее соседей. Это может быть реализовано с помощью массива списков, где каждый элемент массива представляет вершину, а связанный список содержит соседей этой вершины.
    \item{\textbf{Матрица смежности}} \newline 
    В матрице смежности каждый элемент указывает наличие или отсутствие ребра между двумя вершинами. В случае разреженных графов, где большая часть элементов матрицы будет нулевыми, может быть эффективно использована разреженная матрица, где хранятся только ненулевые значения.
    \item{\textbf{Список ребер}} \newline 
    Вместо хранения информации о соседних вершинах можно хранить список всех ребер графа. Каждое ребро тогда представляется парой вершин, которые оно соединяет. Этот подход эффективен для определенных операций, таких как перебор всех ребер.
    \item{\textbf{Компактные структуры данных}} \newline
    Например, CSR (Compressed Sparse Row) и CSC (Compressed Sparse Column), которые оптимизируют использование памяти для разреженных графов, сохраняя при помощи массивов информацию о вершинах, ребрах и их связях, и позволяют эффективно выполнять операции над разреженными графами.
\end{itemize}

Каждый метод имеет свои преимущества и недостатки с точки зрения памяти и производительности. Для сильно разреженных графов, которые были использованы для исследования BFS, в контексте линейной алгебры их представление лучше всего подходит в виде матрицы смежности. Более того, поскольку большинство значений у таких матриц равно нулю, для их хранения целесообрано использовать дополнительную структуру данных, абстракцией над которой выступают вектора и матрицы.

\subsection{Деревья квадрантов}
\textit{Деревья квадрантов (англ. --- Quadtree)} являются рекурсивной структурой данных, широко используемой для эффективного хранения и обработки разреженных матриц. Возможность представлять их компактным образом делает такие деревья ценным инструментом для оптимизации использования памяти.

Quadtree строится на основе деления матрицы смежности графа на четыре равные части (квадранта) и рекурсивного применения этого деления ко всем четырем дочерним квадрантам. Каждый такой элемент может быть представлен в виде узла дерева, а в листьях хранится информация об объектах или данных, находящихся в соответствующем квадранте. Это позволяет эффективно представлять разреженные данные, так как области без объектов могут быть сохранены в упрощенной форме. На рисунке~\ref{f:qtree1} представлена четверка узлов, образующих квадрант. Нумерацию и обозначение квадрантов принято вести слева направо, сверху вниз: (I)~NW~---~North-West, (II)~NE~---~North-East, (III)~SW~---~South-West, (IV)~SE~---~South-East

\begin{figure}[h]
\Tree [.
[.
    [.NW [] ]
    [.NE [] ]
    [.SW [] ]
    [.SE [] ]]
  ]
\captionof{figure}{Схематичное изображение одного из узлов дерева квадрантов и его потомков}
\label{f:qtree1}
\end{figure}

На рисунке~\ref{f:qtree2} продемонстирована ситуация, в которой на некотором уровне квадрант имеет всего один значащий узел, остальные элементы матрицы являются незначащими (в нашем случае для них использовано обозначение \texttt{None}).

\begin{figure}[h]
\Tree [.{}
[.
    [.{}
        [.NW 
            [.{}
                [.None ]
                [.NE [] ]
                [.None ]
                [.SE [] ]
            ]
        ]
    ]
    [.None ]
    [.None ]
    [.None ]
]]
\captionof{figure}{Схематичное изображение нескольких уровней дерева с отсутствующими значениями в некоторых узлах}
\label{f:qtree2}
\end{figure}

Использование \texttt{None} для нулевых элементов не является случайным. Далее рассмотренны языковые особенности, позволившие естестевным образом внедрить описанные ранее абстракции и структуры

\subsection{Языковые особенности \fsharp}
\texttt{Option} --- это тип-контейнер, который может либо содержать значение определенного типа, либо быть пустым \texttt{(None)}. Такое представление незначащих элементов очень удобно по нескольким причинам.
\begin{itemize}
\item{\textbf{Естественное выражение отсутствия значения}} \newline
Деревья квадрантов могут иметь узлы, которые не содержат никаких данных или не имеют потомков. Использование типа \texttt{Option}позволяет явно на это указать, делая код более читабельным.
\item{\textbf{Спосотавление по образцу (англ. --- pattern-matching)}} \newline
Эта особенность языка позволяет легко обрабатывать различные случаи, встречающиеся в узлах деревьев.
\item{\textbf{Безопасность типов}} \newline
Использование \texttt{Option} обеспечивает статическую проверку типов. Например, компилятор предотвратит ошибки, связанные с попыткой обращения к значению там, где его нет.
\end{itemize}

Кроме того, \texttt{F\#} --- преимущественно \textit{функциональный язык} программирования, что делает обработку рекурсивных структур, которыми являются деревья, более простой.