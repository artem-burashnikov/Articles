% !TeX spellcheck = ru_RU
% !TEX root = artem-burashnikov_parallel_bfs_experiments.tex

\section{Подготовка тестового стенда}
\noindent В этом разделе указаны характеристики оборудования, на котором проводились исследования. Также были выдвинуты необходимые гипотезы, проверке которых посвещены проводимые эксперименты, и обозначены используемые метрики и инструменты для фиксирования измерений. Отдельно прокомментирован выбор набора тестируемых данных.



\subsection{Характеристики оборудования}
\noindent Аппаратная конфигурация обладает приведенными ниже характеристиками.
\subsubsection*{Операционная система}

\begin{verbatim}
Operating System: Ubuntu 22.04.2 LTS
\end{verbatim}

\subsubsection*{CPU}
\begin{verbatim}
Architecture:       x86_64
Model name:         AMD Ryzen 5 4500U with Radeon Graphics
Thread(s) per core: 1
Core(s) per socket: 6
\end{verbatim}

\subsubsection*{RAM}
\begin{verbatim}
Total (MB): 9351
\end{verbatim}



\subsection{Исследовательские гипотезы}
\noindent Анализ поставленных задач позволил выдвинуть следующие гипотезы.

\subsubsection*{Гипотеза №1}
\label{t1}
\noindent Ожидается, что в параллельной версии алгоритма обхода в ширину производительность будет значительно превышать последовательную версию на сильно разреженных неориентированных графах, потому что в таких графах большинство вершин имеют небольшую степень, что позволит эффективно распределить работу между потоками и уменьшить накладные расходы на синхронизацию. Таким образом, параллельная версия должна продемонстрировать ощутимое ускорение.

\subsubsection*{Гипотеза №2}
\label{t2}
\noindent Предполагается существование оптимального количества потоков в параллельной версии алгоритма, которое приведет к наибольшему выигрышу в производительности за счет эффективного использования доступных ресурсов вычислительной системы. Его значение ожидается близким к доступному количеству логических ядер используемого процессора.



\subsection{Использованные метрики}
\noindent Для исследования~\hyperref[t1]{\textit{Гипотезы №1}} измерено ускорение (\textit{англ. --- Speedup}) параллельной версии алгоритма относительно последовательной со следующим набором контролируемых параметров:
\begin{itemize}
    \item количество вершин в графе;
    \item плотность графа;
    \item количество используемых потоков.
\end{itemize}
\textit{Speedup} ($S$) вычисляется по формуле:
\begin{equation}
\label{eq:speedup}
	\text{S} = \frac{T_{old}}{T_{new}},
\end{equation}
где $T_{old}$ - время работы последовательной версии алгоритма, $T_{new}$ - время работы параллельной версии алгоритма при заданных параметрах.

Для поиска оптимального значения, обозначенного в~\hyperref[t2]{\textit{Гипотезе №2}}, проанализировано ускорение параллельной версии алгоритма на сильно разреженных графах с использованием разного количества потоков: 1, 2, 4, 8, 16. Выбор таких величин обусловлен ограничениями используемого оборудования.



\subsection{Инструменты для измерений}
\noindent Все замеры выполнены с использованием библиотеки для измерения производительности \texttt{BenchmarkDotNet v0.13.4}~\footnote{\href{https://benchmarkdotnet.org/}{Библиотека .NET для замеров производительности. Дата посещения: \DTMdate{2023-05-23}}}, разрабатываемой и поддерживаемой для платформы \texttt{.NET}.



\subsection{Набор данных}
\noindent Для фиксации исследуемых величин выбраны 11 различных разреженных квадратных матриц из коллекции университета Флориды~\cite{matrixData}. Плотные матрицы и разреженные матрицы с крайне малым количеством вершин ($<$ 100) созданы искусственно, потому что такие синтетические данные не нарушают чистоту эксперимента, так как плотные графы редко встречаются на практике, а очень маленькие размеры представляют лишь формальный интерес, и ручная регулировка количества вершин и плотности позволит точнее определить влияние этих параметров на производительность.

Популярный набор для тестирования плотных графов \texttt{MIVIA Large Dense Graphs}~\footnote{\href{https://mivia.unisa.it/datasets/graph-database/mivia2-graph-database/}{Ресурс исследовательной лаборатории Mivia университета Solerno. Дата посещения: \DTMdate{2023-05-23}}} является синтетическим, однако предоставляется в неудобном для данной работы формате, поэтому файлы графов с малым количеством вершин в количестве 10 штук были созданы согласно стандарту файлов \texttt{Matrix Market}~\footnote{\href{https://math.nist.gov/MatrixMarket/}{Главная страница проекта Matrix Market. Дата посещения: \DTMdate{2023-05-23}}} с помощью библиотеки \texttt{NetworkX}~\footnote{\href{https://networkx.org/}{Библиотека анализа сложных систем для языка Python. Дата посещения: \DTMdate{2023-05-23}}} для языка \texttt{Python}. В листинге~\ref{gen_example} продемонстрирован использованный для генерации графов код.

\begin{algorithm}[ht]
\floatname{algorithm}{Листинг}
\caption{Пример кода для генерации графов на языке Python с использованием библиотеки \texttt{NetworkX}}
\label{gen_example}
\begin{lstlisting}[language=python]
import networkx
import numpy
import scipy.io  # for mmread() and mmwrite()
import io  # Use BytesIO as a stand-in for a Python file object

# Specify graph parameters
mininumSize = 10
maximumSize = 100+1
step = 10

# Specify density list
p_list = [0.1]

for n in range(mininumSize, maximumSize, step):
    for p in p_list:

        fh = io.BytesIO()

        # Generate random graph
        G = networkx.gnp_random_graph(n, p)

        # Choose random label on existing edge 
        for u, v in G.edges:
           G[u][v]['weight'] = numpy.random.random()

        # Convert to sparse matrix representation
        sparseArray = networkx.to_scipy_sparse_array(G)

        # Write output to a file
        scipy.io.mmwrite(fh, sparseArray)
        with open("graphs/" + str(n)+"_" + str(p) + ".mtx", 'w', encoding='utf-8') as file:
            file.write(fh.getvalue().decode('utf-8'))

\end{lstlisting}
\end{algorithm}


Информация о разреженных матрицах представлена в таблице~\ref{table:sparse_matrices}. Для обозначения числа ненулевых элементов используется аббревиатура \textit{Nnz}. Приведено официальное (при наличии) название матрицы, количество строк, количество ненулевых элементов, отношение ненулевых элементов к числу всех возможных элементов (плотность).

\begin{table}[ht]
\begin{center}
\rowcolors{2}{black!2}{black!10}
\begin{tabular}{l|r|r|r|}
\hline
Матрица $M$ & Количество cтрок $R$ & $Nnz$ & $Nnz$/$R^{2}, \%$ \\
\hline
\hline
10\_0.1                         &      10          &      2            & 4.4 \\
20\_0.1                         &      20          &      25           & 13.1 \\
30\_0.1                         &      30          &      47           & 10.8 \\
40\_0.1                         &      40          &      90           & 11.5 \\
50\_0.1                         &      50          &      114          & 9.3 \\
60\_0.1                         &      60          &      181          & 10.2 \\
70\_0.1                         &      70          &      247          & 10.2 \\
80\_0.1                         &      80          &      309          & 9.7 \\
90\_0.1                         &      90          &      377          & 9.4 \\
100\_0.1                        &      100         &      515          & 8.4 \\
yalea\_10nn                    &      165         &      1,134        & 8.4 \\
glass\_10nn                    &      214         &      1,493        & 6.6 \\
usair97                        &      332         &      2,126        & 3.9 \\ 
olivetti\_norm\_10nn           &      400         &      2,828        & 3.6 \\ 
spectro\_10nn                  &      531         &      3,711        & 2.6 \\ 
vehicle\_10nn                  &      846         &      5,447        & 1.5 \\
g51                            &      1,000       &      5,909        & 1.2 \\
yeast\_30nn                    &      1,484       &      31,175       & 2.8 \\
dataset16mfeatkarhunen\_10nn   &      2,000       &      13,834       & 0.7 \\
misknowledgemap                &      2,427       &      28,511       & 0.9 \\
mycielskian12                  &      3,071       &      203,600      & 4.3 \\
\hline
\end{tabular}
\end{center}
\caption{Разреженные матричные данные}
\label{table:sparse_matrices}
\end{table}



\subsection{Эксперимент}
\noindent Результаты измерений ускорения относительно уровней параллельности представлены в таблицах~\ref{results1},~\ref{results2},~\ref{results3},~\ref{results4},~\ref{results5},~\ref{results6}. Каждый уровень соответствует 2 потокам. Так, на уровне 2 в асинхронных вычислениях задействованы 4 потока, на уровне 3 --- 8 и т.д. 

\subsubsection*{Проверка инструмента измерения производительности}
\noindent  Измерения, полученные с помощью \texttt{BenchmarkDotNet} были проверены на нормальность с помощью библиотек языка \texttt{Python}: \texttt{SciPy v1.10.1}\footnote{Адрес в интернете \url{https://scipy.org/} (дата доступа:   \DTMdate{2023-05-24}).}, \texttt{NumPy v1.24.3}\footnote{Адрес в интернете\url{ https://numpy.org/} (дата доступа:   \DTMdate{2023-05-24}).} и \texttt{Matplotlib v3.7.1}\footnote{Адрес в интернете\url{https://matplotlib.org/} (дата доступа: \DTMdate{2023-05-24}).}. Для этого отдельно выполнены 100 измерений производительности алгоритма на графе \texttt{mycielskian12} с параметром \texttt{parallelLevl} $=$ 3. Граф выбран как предположительно обладающий достаточным для эффективного применения асинхронных вычислений количества вершин. Значение \texttt{parallelLevel} выбиралось как предположительно оптимальное. Результаты измерений зафиксированы в таблице~\ref{measured_time}.

\begin{table}[ht]
  \centering
  \resizebox{\textwidth}{!}{
  \begin{tabular}{*{10}{c}}
    \toprule
    Время 1 (мс) & Время 2 (мс) & Время 3 (мс) & Время 4 (мс) & Время 5 (мс) & Время 6 (мс) & Время 7 (мс) & Время 8 (мс) & Время 9 (мс) & Время 10 (мс) \\
    \midrule
    130.273 & 193.6342 & 816.4792 & 147.604 & 154.5787 & 144.4763 & 168.322 & 157.4245 & 165.3245 & 174.7072 \\
    130.0219 & 207.0966 & 169.0884 & 156.9507 & 143.6333 & 159.6349 & 148.3321 & 141.0419 & 123.8125 & 103.7556 \\
    155.7681 & 173.8194 & 141.1922 & 144.1792 & 127.7025 & 128.5758 & 221.2754 & 164.8696 & 163.6834 & 122.9248 \\
    192.0396 & 143.0681 & 121.7847 & 141.0921 & 138.0951 & 141.7283 & 132.8897 & 186.3074 & 186.3662 & 135.5439 \\
    144.3839 & 131.7593 & 128.9409 & 119.6813 & 144.5015 & 153.9668 & 231.7988 & 194.2572 & 152.5939 & 175.0124 \\
    213.1968 & 152.7859 & 166.767 & 179.1278 & 154.8963 & 136.6072 & 211.6087 & 146.9048 & 179.1302 & 178.0791 \\
    134.6695 & 193.0113 & 170.6718 & 158.6846 & 195.0692 & 140.8904 & 181.9895 & 203.541 & 139.4999 & 154.5966 \\
    163.0994 & 149.5508 & 139.4742 & 252.4698 & 222.6095 & 160.4422 & 160.3885 & 121.6504 & 145.7919 & 215.9388 \\
    151.9468 & 133.891 & 146.2433 & 170.738 & 137.8877 & 176.1576 & 159.5394 & 156.7406 & 194.014 & 166.329 \\
    155.0427 & 152.6318 & 124.2822 & 183.2932 & 135.5936 & 180.9422 & 159.2848 & 152.0111 & 117.932 & 203.1799 \\
    \bottomrule
  \end{tabular}
  }
\caption{Измерения, полученные во время работы параллельной версии алгоритма на графе mycielskian12, parallelLevl = 3}\label{measured_time}
\end{table}

С помощью функций \texttt{scipy.stats.shapiro()} и \texttt{scipy.stats.normaltest()} проверялось соответствие полученных величин нормальному распределению. Значение \texttt{pvalue} в результате соответствовало $0.15$ (Шапиро) и $0.13$ (Пирсон), что удовлетворяет критерию нормальности.
По данным в таблице~\ref{measured_time} построена гистограмма~\ref{histogram}. Вид гистограммы соответствует нормальному распределению.

\begin{table}[ht]
  \centering
\includesvg[width=\textwidth]{histogram}
\caption{Гистограмма распределения значений, полученных, при проведении проверки инструмента BenchmarkDotNet}
\label{histogram}
\end{table}


\subsubsection*{Анализ результатов}
\noindent Ниже даны ответы на вопросы исследования.
\newline

\noindent\hyperref[rq1]{\textbf{RQ1:}}
Результаты ускорения, зафиксированного на графиках~\ref{results1},~\ref{results2} показали, что для \emph{разреженных} графов с размером вершин менее 100 выгоднее использовать последовательную реализацию алгоритма обхода в ширину. Причем параллельная версия показывает ускорение на 4 потоках, начиная с графа со 100 вершинами. Такие значения объясняются тем, что вершин и рёбер хоть и достаточно, чтобы увидеть рост производительности при параллельных вычислениях, их не хватает, для получения преимущества перед накладными расходами, возникающими при последующем увеличении количества используемых логических процессоров. 

Результаты в~\ref{results3},~\ref{results4} демонстрируют рост ускорения с увеличением количества вершин, тем самым преимущество параллельной версии для разреженных графов становится очевидным.

Полученные выводы согласуются с поставленной ~\hyperref[t1]{\textit{Гипотезой №1}}.
\newline

\begin{table}
  \centering
\includesvg[width=\textwidth]{figures/10-50-sparse-speedup}
\caption{Ускорение параллельной версии BFS относительно последовательной для разреженных графов с количеством вершин в диапазоне 10 --- 50 из доступного набора графов}
\label{results1}
\end{table}

\begin{table}
  \centering
\includesvg[width=\textwidth]{figures/60-100-sparse-speedup}
\caption{Ускорение параллельной версии BFS относительно последовательной для разреженных графов с количеством вершин в диапазоне 60 --- 100 из доступного набора графов}
\label{results2}
\end{table}

\noindent\hyperref[rq2]{\textbf{RQ2:}}
На графиках~\ref{results3},~\ref{results4} выделяется оптимальное количество потоков, равное 8, дающее максимальный прирост производительности при использовании параллельной версии обхода в ширину. Полученное значение является верхней границей количества ядер используемого процессора. Отмечено, что при росте количества вершин, это оптимальное значение может смещаться в сторону большего количества потоков. Например, алгоритм на графе \texttt{mycielskian12} показал увеличение ускорения при использовании 16 потоков, что вызвано особенностями архитектуры процессора и оптимизацией, проводимой операционной системой. Предполагается, что для процессоров с большим количеством физических и логических ядер лучший параметр используемых потоков находится на уровнях выше (например, 4, 5 и т.д.). 

Наблюдения об оптимальном значении согласуется с выставленной ~\hyperref[t2]{\textit{Гипотезой №2}}.
\newline

\begin{table}
  \centering
\includesvg[width=\textwidth]{figures/165-846-sparse-speedup}
\caption{Ускорение параллельной версии BFS относительно последовательной для разреженных графов с количеством вершин в диапазоне 165 --- 846 из доступного набора}
\label{results3}
\end{table}

\begin{table}
  \centering
\includesvg[width=\textwidth]{figures/1000-3071-sparse-speedup}
\caption{Ускорение параллельной версии BFS относительно последовательной для разреженных графов с количеством вершин в диапазоне 1000 --- 3071 из доступного набора}
\label{results4}
\end{table}

Отдельно измерено влияние плотности на количество вершин, при котором параллельная версия BFS становится эффективнее. Рассматривая параметр плотности в значении $0.7$ и постепенно снижая его для графов с количеством вершин не более $100$, мы наблюдали смещение критического значения размера в сторону уменьшения. Результаты для \textit{density} $=$ $0.7$ представлены на графике~\ref{results5}. Параллельная реализация показала ускорение для размеров $100$, $90$ и $80$, но оказалась медленнее для плотного графа с количеством вершин, равным $70$.

\begin{table}
  \centering
\includesvg[width=\textwidth]{figures/100-70-density-07}
\caption{Ускорение параллельной версии BFS относительно последовательной графов плотности 0.7 с количеством вершин 70, 80, 90, 100}
\label{results5}
\end{table}

На графике~\ref{results6} параллельный алгоритм демонстрирует ускорение для графа с параметром плотности $0.6$ на $80$ вершинах, но работает не лучше, чем последовательная версия на $70$ вершинах. Причем для $2$ потоков накладные расходы на их обслуживание превышают выигрыш производительности, поэтому наблюдается общее снижение ускорения, но для $4$ потоков удаётся распределить задачи так, что не происходит ни падения, ни роста эффективности.

\begin{table}
  \centering
\includesvg[width=\textwidth]{figures/80-70-density-06}
\caption{Ускорение параллельной версии BFS относительно последовательной для графов плотности 0.6 с количеством вершин 70, 80}
\label{results6}
\end{table}

Анализ~\ref{results5} и~\ref{results6} позволил заключить, что плотность графа уменьшает нижнюю границу значения, при котором параллельная версия становится выгоднее последовательной. То есть прирост ускорения происходит для плотных структур на меньшем количестве вершин, чем для разреженных.
Это объясняется тем, что с ростом плотности увеличивается количество ребёр, что позволяет распределить вычислительные задачи между используемым потоками более эффективно, так как умножаются вектора и матрицы с достаточным для этого количеством значащих элементов. Для графов с количеством вершин более 100 и параллельная, и последовательная версии будут включать больше операций, обрабатываемых процессором, поэтому негативных последствий для эффективности параллельной версии не наблюдается.