% !TeX spellcheck = ru_RU
% !TEX root = artem-burashnikov_parallel_bfs_experiments.tex

\section{Детали реализации}
%TODO Снести секцию GraphBlas выше в сопутствующие исследования.
\subsection{GraphBlas}
%TODO Изменить citation на книжку, а url в сноску.
Обход в ширину был реализован на языке \texttt{F\#} с использованием идей, заложенных \texttt{GraphBlas}~\cite{graphBlas}.
%TODO --- тире
%TODO - дефис
%TODO -- диапазоны
\texttt{GraphBlas} --- это инициатива, нацеленная на создание стандартизованного интерфейса для разработки графовых алгоритмов.
%TODO "Целью этой инициативы" убрать
Целью этой инициативы является обеспечение высокой производительности и переносимости для широкого спектра алгоритмов, работающих с различными графовыми структурами.

%TODO языково-независимая?
Пользователю предоставляется спецификация, определяющая набор абстрактных операций линейной алгебры: умножение матрицы на вектор, сложение векторов и умножение матрицы на матрицу. Описанная семантика и требования для интерфейса позволяют создавать собственные реализации на различных языках программирования и для различных аппаратных платформ. 

%TODO Добавить теоретическую справку про деревья квадрантов.
%TODO Ссылку на теорию и описать. Вынести выше.
%TODO Добавить теоретическую справку на неочевидные языковые особенности.
\subsection{Концепция алгоритма}
Основной принцип состоит в том, что применение операции умножения вектора на матрицу, определенной в GraphBlas, является переходом от одних вершин графа к другим по инцидентным этим вершинам рёбрам.
В свою очередь вектора представлены в виде двоичного дерева, а матрицы --- в виде дерева квадрантов. Такое представление удобно не только для хранения разреженных структур в памяти, но и для внедрения параллелизма. Рассмотрим конкретные шаги алгоритма.
%TODO в item запихнуть Шаг 1 или, возможно, убрать кружочки
\begin{itemize}
    \item \textbf{Шаг 1}. Создается матрица смежности, соответствующая данному графу. В нашем случае по матрице смежности, представленной как список координат, строится дерево квадрантов, причем использование \texttt{F\#} позволяет естественно выражать отсутствующие рёбра и отсутствующие метки через тип \texttt{Option}. Значения в ячейках матрицы заполняются значениями на соответствующих рёбрах графа.
    \item \textbf{Шаг 2}. Задаются два вектора.
    \begin{enumerate}
        \item Фронт: вектор, в котором каждый индекс соответствует вершине графа, а значения указывают на текущие просматриваемые вершины. Отсутствие вершины в текущем фронте обозначается как \texttt{Option None}.
        \item Результирующий вектор, который при инициализации совпадает с фронтом а в процессе работы алгоритма аккумулирует промежуточные результаты (например, длину минимального пути).
    \end{enumerate}
    \item \textbf{Шаг 3}. Выполняется умножение вектора состояний на матрицу смежности. В качестве поэлементных операций сложения и умножения используются логические \texttt{ИЛИ} и \texttt{И}. После каждого умножения на результирующий вектор применяется маска, чтобы алгоритм не обрабатывал уже посещенные вершины. Результатом итерации является новый фронт и обновленный результирующий вектор.
\end{itemize}

%TODO Возможно, добавить примеры алгоритма
Шаг 3 повторяется до тех пор, пока не будут достигнуты требуемые условия остановки. Например, все вершины станут исследованы или произойдет выполнение определенного условия.

%TODO Изменить название секции
%TODO Добавить ссылку на листинг 1
\subsection{Параллелизм}
Благодаря рекуррентной природе деревьев, являющихся в нашем случае внутренним представлением векторов и матриц, реализованный алгоритм естественным образом поддаётся распараллеливанию. В листинге 1 представлен псевдокод с использованием абстрактных операций линейной алгебры. \textit{Минимальными единицами} такой операции являются вектор размера \texttt{1\times2} и матрица размера \texttt{2\times2}, что на каждой итерации позволяет использовать до четырех потоков для разделения вычислений между ними.
%TODO Добавить связь формулы с текстом
\begin{center}
    \begin{tabular}{ccc}
        $\begin{bmatrix} a_{11} & a_{12} \end{bmatrix}$
        $\times$
        $\begin{bmatrix} b_{11} & b_{12} \\ b_{21} & b_{22} \end{bmatrix}$
        =
        $\begin{bmatrix} a_{11} \times b_{11} + a_{12} \times b_{21} \\ a_{11} \times b_{12} + a_{12} \times b_{22} \end{bmatrix}$
    \end{tabular}
\end{center}

\lstset{style=codelistingstyle}

\begin{algorithm}[ht]
\floatname{algorithm}{Листинг}
\caption{Псевдокод параллельного алгоритма обхода в ширину c использованием методов линейной алгебры}
\label{alg:bfs_example}
\begin{lstlisting}[language=pseudoFSharp]
function BFS (parallelLevel, startingVertices, adjacencyMatrix):

    matrix := makeSparseMatrix from adjacencyMatrix
    
    frontier := makeSparseVector from startVertices
    
    result := frontier

    def recursive function inner (frontier, result, counter):
        if frontier.IsEmpty then
            return result
        else
            newFrontier :=
                call multiplyVectorByMatrix (parallelLevel, frontier, matrix)
                
            newFrontier :=
                call applyMask (result, newFrontier)

            newResult :=
                call updateResult (count, result, newFrontier)

            newCounter := counter + 1
            
            call inner (newFrontier, newResult, newCounter)

    call inner (frontier, result, 1)
end function
\end{lstlisting}
\end{algorithm}

Элементы матрицы --- поддеревья, поэтому вычисление элемента $a_{is} \times b_{sj}$ является рекурсивным вызовом на соответствующем поддереве. В представленной работе операция умножения над \textit{минимальными единицами} разбивается на два потока: один из потоков отвечает за вычисление значения в первой строке результирующего вектора, а другой поток --- за вычисление во
%TODO Убрать конкретику про железо!!!
второй. Такой подход выбран потому, что использовавшееся для постановки экспериментов оборудование имеет небольшое количество физических и виртуальных ядер процессора. Кроме того, при необходимости увеличить количество потоков на вход в BFS передаётся целый положительный параметр \textit{parallelLevel}, величина которого уменьшается с каждым вызовом тела функции, в результате чего производятся дополнительные асинхронные вычисления на следующем уровне рекурсии. Этот передаваемый аргумент позволяет точно контролировать степень распараллеливания.

%TODO Изменить структуру, убрав конкретику про F#
%TODO Засунуть перед самими экспериментами
\subsection{Реализация алгоритма на языке F\#}
Ниже приведены ссылки на варианты исполнения обозначенных алгоритмов.
\begin{itemize}
%TODO edit footnote
	\item Обход в ширину на языке \texttt{F\#}\footnote{\url{https://github.com/artem-burashnikov/2022-Programming-Technologies-F-sharp-course/blob/fb0ba5a5acf9ab045d4e52da22681a9264ad5b32/src/spbu-fsharp/BreadthFirstSearch.fs}}.
	\item Умножения вектора на матрицу как абстракция над операциями над деревьями\footnote{\url{https://github.com/artem-burashnikov/2022-Programming-Technologies-F-sharp-course/blob/fb0ba5a5acf9ab045d4e52da22681a9264ad5b32/src/spbu-fsharp/MatrixAlgebra.fs}}.
\end{itemize}

Отметим, что обе функции поддерживают как последовательное, так и параллельное исполнение.
