% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Эксперимент}

\subsection{Характеристики оборудования}
Оборудование, на котором были поставлены описанные далее эксперименты, обладает следующими характеристиками:
\subsubsection*{OS and Kernel}
\begin{verbatim}
Operating System: Ubuntu 22.04.2 LTS
          Kernel: Linux 5.19.0-41-generic
\end{verbatim}

\subsubsection*{CPU}
\begin{verbatim}
Architecture:       x86_64
Model name:         AMD Ryzen 5 4500U with Radeon Graphics
Thread(s) per core: 1
Core(s) per socket: 6
Socket(s):          1
CPU max MHz:        2375,0000
CPU min MHz:        1400,0000
L1d cache:          192 KiB (6 instances)
L1i cache:          192 KiB (6 instances)
L2 cache:           3 MiB (6 instances)
L3 cache:           8 MiB (2 instances)
\end{verbatim}

\subsubsection*{GPU}
\begin{verbatim}
Device: [AMD/ATI] Renoir (rev c3)
Memory: 256M
\end{verbatim}

\subsubsection*{RAM}
\begin{verbatim}
Memory:      7304
Swap memory: 2047
Total:       9351 
\end{verbatim}

\subsection{Исследовательские вопросы}
Анализ поставленных задач позволил выдвинуть следующие гипотезы:
{\parindent0pt
    
    \subsubsection*{RQ1}
    \label{RQ1}
    Ожидается, что в параллельной версии алгоритма обхода в ширину производительность будет значительно превышать последовательную версию на сильно разреженных неориентированных графах, потому что в таких графах большинство вершин имеют небольшую степень, что позволит эффективно распределить работу между потоками и уменьшить накладные расходы на синхронизацию. Таким образом, параллельная версия должна продемонстрировать ощутимое ускорение.
}
{\parindent0pt
    \subsubsection*{RQ2}
    \label{RQ2}
    Предполагается существование оптимального количества потоков в параллельной версии алгоритма, которое приведет к наибольшему выигрышу в производительности за счет эффективного использования доступных ресурсов вычислительной системы.
}

\subsection{Использованные метрики}

Для исследования~\hyperref[RQ1]{RQ1} решено замерять ускорение (Speedup) параллельной версии алгоритма относительно последовательной со следующим набором контролируемых параметров:
\begin{itemize}
    \item количество вершин в графе;
    \item плотность графа;
    \item количество используемых потоков.
\end{itemize}

Для поиска оптимального значения, обозначенного в~\hyperref[RQ2]{RQ2}, будет проанализировано среднее время работы параллельной версии алгоритма на сильно разреженных графах с использованием разного количества потоков: 1, 2, 4, 8, 16.

Все замеры будут выполнены с использованием библиотеки для измерения производительности \texttt{BenchmarkDotNet}~\cite{benchTool}, разрабатываемой и поддерживаемой для платформы \texttt{.NET}.

\subsection{Набор данных}
Для фиксации исследуемых величин были выбраны 10 различных разреженных квадратных матриц из коллекции университета Флориды~\cite{matrixData}.
Плотные матрицы было решено генерировать из разреженных постепенным и аккуратным добавлением ребёр до тех пор, пока структура не станет обладать нужными характеристиками. При этом необходимо, чтобы матрица смежности графа заполнялась значениями меток равномерно по всей площади двумерной сетки, потому как случайная группировка ребёр вокруг определенного квадранта матрицы может привести к нежелательным последствиям из-за особенности внутреннего представления матриц в виде деревьев квадрантов.

Информация о выбранных данных представлена в таблице~\ref{table:sparse_matrices}. 
Для обозначения числа ненулевых элементов используется аббревиатура \textit{Nnz}. 

В ней приведено официальное название матрицы (синтетические матрицы имеют то же имя, что и их прародители, но с добавлением префикса \textit{S}), количество строк, количество ненулевых элементов, соотношение ненулевых элементов к числу всех возможных элементов.

\begin{table}[h]
\begin{center}
\caption{Разреженные матричные данные}
\label{table:sparse_matrices}
\rowcolors{2}{black!2}{black!10}
\scalebox{1.0}{
\begin{tabular}{|l|r|r|r|}
\hline
Матрица & Количество cтрок $R$ & Nnz $M$ & Nnz/$R^{2}$ \\
\hline
\hline
%wing             &    62,032      &   243,088    & 3.9 \\
%luxembourg\_osm  &   114,599      &   239,332    & 2.0 \\
%amazon0312       &   400,727      & 3,200,400    & 7.9 \\
%amazon-2008      &   735,323      & 5,158,388    & 7.0 \\
%web-Google       &   916,428      & 5,105,039    & 5.5 \\
%roadNet-PA       & 1,090,920      & 3,083,796    & 2.8 \\
%roadNet-TX       & 1,393,383      & 3,843,320    & 2.7 \\
%belgium\_osm     & 1,441,295      & 3,099,940    & 2.1 \\
%roadNet-CA       & 1,971,281      & 5,533,214    & 2.8 \\
%netherlands\_osm & 2,216,688      & 4,882,476    & 2.2 \\ 
\hline
\end{tabular}
}
\end{center}
\end{table}


\subsection{Постановка эксперимента}
%Результаты понятно что такое. Тут всякие таблицы и графики, как в таблице \ref{time_cmp_obj_func}. Обратите внимание, как цифры выровнены по правому краю, названия по центру, а разделители $\times$ и $\pm$ друг под другом.

%Скорее всего Ваши измерения будут удовлетворять нормальному распределению, в идеале это надо проверять с помощью критерия Кол\-могорова и т.п.
%Если критерий этого не подтверждает, то у Вас что-то сильно не так с измерениями, надо проверять кэши процессора, отключать Интернет во время измерений, подкручивать среду исполне\-ния (англ. runtime), что\-бы сборка мусора не вмешивалась и т.п.
%Если критерий удовлетворён, то необходимо либо указать мат. ожидание и доверительный/предсказы\-вающий интервал, либо написать, что все измерения проводились с погрешностью, например, в 5\%.
%Замечание: если у вас получится улуч\-шение производительности в пределах погреш\-ности, то это обязательно вызовет вопросы.

%В этом разделе надо также коснуться Research Questions.

%\subsubsection{RQ1} Пояснения
%\subsubsection{RQ2} Пояснения

%\begin{table}
%\def\arraystretch{1.1}  % Растяжение строк в таблицах
%\setlength\tabcolsep{0.2em}
%\centering
% \resizebox{\linewidth}{!}{%
%    \caption{Производительность какого-то алгоритма при различных разрешениях картинок  (меньше~--- лучше), в мс.,  CI=0.95. За пример таблички кидаем чепчики в честь Я.~Кириленко}
%    \begin{tabular}[C]{
%    S[table-format=4.4,output-decimal-marker=\times]
%    *4{S
%          [table-figures-uncertainty=2, separate-uncertainty=true, table-align-uncertainty=true,
%          table-figures-integer=3, table-figures-decimal=2, round-precision=2,
%          table-number-alignment=center]
%          }
%    }
%    \toprule
%        \multicolumn{1}{r}{Resolution} & \multicolumn{1}{r}{\textsc{TENG}} & \multicolumn{1}{r}{\textsc{LAPM}} &
%        \multicolumn{1}{r}{\textsc{VOLL4}} \\ \midrule
%        1920.1080 & 406.23 \pm 0.94 & 134.06 \pm 0.35 & 207.45 \pm 0.42  \\ \midrule
%        1024.768  & 145.0 \pm 0.47  & 39.68 \pm 0.1   &  52.79  \pm 0.1 \\ \midrule
%        464.848   & 70.57 \pm 0.2   & 19.86 \pm 0.01 %    & 32.75  \pm 0.04 \\ \midrule
%        640.480   & 51.10 \pm 0.2   & 14.70 \pm 0.1 & 24  \pm 0.04 \\ \midrule
%        160.120   & 2.4 \pm 0.02    & 0.67 \pm 0.01      & 0.92  \pm 0.01 \\
%        \bottomrule
%    \end{tabular}%
%}
%    \label{time_cmp_obj_func}
%\end{table}

%\clearpage
%\input{figures/bigtable}

\subsection{Анализ результатов}

%Чуть более неформальное обсуждение, то, что сделано. Например, почему метод работает лучше остальных? Или, что делать со случаями, когда метод классифицирует вход некорректно.
