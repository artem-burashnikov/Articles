% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Эксперимент}

\subsection{Характеристики оборудования}
Оборудование, на котором были поставлены описанные далее эксперименты, обладает следующими характеристиками:
\subsubsection*{OS and Kernel}
\begin{verbatim}
Operating System: Ubuntu 22.04.2 LTS
          Kernel: Linux 5.19.0-41-generic
\end{verbatim}

\subsubsection*{CPU}
\begin{verbatim}
Architecture:       x86_64
Model name:         AMD Ryzen 5 4500U with Radeon Graphics
Thread(s) per core: 1
Core(s) per socket: 6
Socket(s):          1
CPU max MHz:        2375,0000
CPU min MHz:        1400,0000
L1d cache:          192 KiB (6 instances)
L1i cache:          192 KiB (6 instances)
L2 cache:           3 MiB (6 instances)
L3 cache:           8 MiB (2 instances)
\end{verbatim}

\subsubsection*{GPU}
\begin{verbatim}
Device: [AMD/ATI] Renoir (rev c3)
Memory: 256M
\end{verbatim}

\subsubsection*{RAM}
\begin{verbatim}
Memory:      7304
Swap memory: 2047
Total:       9351 
\end{verbatim}

\subsection{Исследовательские вопросы}
При анализе поставленных задач были выдвинуты следующие гипотезы:
{\parindent0pt
    
    \subsubsection*{RQ1}
    \label{RQ1}
    Ожидается, что в параллельной версии алгоритма обхода в ширину производительность будет значительно превышать последовательную версию на сильно разреженных неориентированных графах, потому что в таких графах большинство вершин имеют небольшую степень, что позволит эффективно распределить работу между потоками и уменьшить накладные расходы на синхронизацию. Таким образом, параллельная версия должна продемонстрировать ощутимое ускорение.
}
{\parindent0pt
    \subsubsection*{RQ2}
    \label{RQ2}
    Предполагается существование оптимального количества потоков в параллельной версии алгоритма, которое приведет к наибольшему выигрышу в производительности за счет эффективного использования доступных ресурсов вычислительной системы.
}

\subsection{Использованные метрики}

Для исследования \hyperref[RQ1]{RQ1} решено замерять ускорение параллельной версии алгоритма относительно последовательной со следующим набором контролируемых параметров:
\begin{itemize}
    \item количество вершин в графе;
    \item плотность графа;
    \item количество используемых потоков.
\end{itemize}

Для поиска оптимального значения, обозначенного в \hyperref[RQ2]{RQ2}, будет проанализировано среднее время работы параллельной версии алгоритма на сильно разреженных графах с использованием разного количества потоков: 2, 4, 8.

\subsection{Использованные данные}

\subsection{Постановка эксперимента}
%Результаты понятно что такое. Тут всякие таблицы и графики, как в таблице \ref{time_cmp_obj_func}. Обратите внимание, как цифры выровнены по правому краю, названия по центру, а разделители $\times$ и $\pm$ друг под другом.

%Скорее всего Ваши измерения будут удовлетворять нормальному распределению, в идеале это надо проверять с помощью критерия Кол\-могорова и т.п.
%Если критерий этого не подтверждает, то у Вас что-то сильно не так с измерениями, надо проверять кэши процессора, отключать Интернет во время измерений, подкручивать среду исполне\-ния (англ. runtime), что\-бы сборка мусора не вмешивалась и т.п.
%Если критерий удовлетворён, то необходимо либо указать мат. ожидание и доверительный/предсказы\-вающий интервал, либо написать, что все измерения проводились с погрешностью, например, в 5\%.
%Замечание: если у вас получится улуч\-шение производительности в пределах погреш\-ности, то это обязательно вызовет вопросы.

%В этом разделе надо также коснуться Research Questions.

%\subsubsection{RQ1} Пояснения
%\subsubsection{RQ2} Пояснения

%\begin{table}
%\def\arraystretch{1.1}  % Растяжение строк в таблицах
%\setlength\tabcolsep{0.2em}
%\centering
% \resizebox{\linewidth}{!}{%
%    \caption{Производительность какого-то алгоритма при различных разрешениях картинок  (меньше~--- лучше), в мс.,  CI=0.95. За пример таблички кидаем чепчики в честь Я.~Кириленко}
%    \begin{tabular}[C]{
%    S[table-format=4.4,output-decimal-marker=\times]
%    *4{S
%          [table-figures-uncertainty=2, separate-uncertainty=true, table-align-uncertainty=true,
%          table-figures-integer=3, table-figures-decimal=2, round-precision=2,
%          table-number-alignment=center]
%          }
%    }
%    \toprule
%        \multicolumn{1}{r}{Resolution} & \multicolumn{1}{r}{\textsc{TENG}} & \multicolumn{1}{r}{\textsc{LAPM}} &
%        \multicolumn{1}{r}{\textsc{VOLL4}} \\ \midrule
%        1920.1080 & 406.23 \pm 0.94 & 134.06 \pm 0.35 & 207.45 \pm 0.42  \\ \midrule
%        1024.768  & 145.0 \pm 0.47  & 39.68 \pm 0.1   &  52.79  \pm 0.1 \\ \midrule
%        464.848   & 70.57 \pm 0.2   & 19.86 \pm 0.01 %    & 32.75  \pm 0.04 \\ \midrule
%        640.480   & 51.10 \pm 0.2   & 14.70 \pm 0.1 & 24  \pm 0.04 \\ \midrule
%        160.120   & 2.4 \pm 0.02    & 0.67 \pm 0.01      & 0.92  \pm 0.01 \\
%        \bottomrule
%    \end{tabular}%
%}
%    \label{time_cmp_obj_func}
%\end{table}

%\clearpage
%\input{figures/bigtable}

\subsection{Анализ результатов}

%Чуть более неформальное обсуждение, то, что сделано. Например, почему метод работает лучше остальных? Или, что делать со случаями, когда метод классифицирует вход некорректно.
