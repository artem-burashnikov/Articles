% !TeX spellcheck = ru_RU
% !TEX root = artem-burashnikov_parallel_bfs_experiments.tex

\section{Обзор предметной области}
\label{sec:relatedworks}
\noindent Перед проведения эксперимента необходимо ознакомиться с существующими работами, затрагивающими проблемы многопоточной реализации BFS. Кроме того, требуется рассмотреть преимущества использования абстрактных операций линейной алгебры в алгоритме обхода в ширину, отметив выбор подходящей структуры данных для хранения матриц и векторов, а также обратить внимание на особенности выбранного для реализации языка программирования.



\subsection{Существующие исследования}
Алгоритм обхода графа в ширину ввиду своей прикладной значимости был проанализирован в разном контексте в ряде исследовательских работ. Некоторые из них рассмотрены далее.

В работе~\cite{adaptiveBFS} отмечается, что производительность BFS в значительной мере зависит от топологии подаваемого на вход графа. Ся Инлун (Xia Yinglong) и Празанна Виктор (Prasanna Viktor) показали, что в случае большого количества итераций алгоритма при малых количествах вершин/ребер между итерациями (то есть малом количестве вершин во фронте на каждой итерации) параллельная версия терпит снижение производительности из-за накладных расходов на создание параллельных задач.

Кроме того, в исследовании~\cite{scalableBFS} Вират Агарвал (Virat Agarwal) и др. продемонстрировали, что последовательная версия алгоритма в некоторых ситуациях оказывается предпочтительнее не оптимизированной параллельной ввиду большой задержки работы с памятью и высокой вычислительной стоимостью её синхронизации. 

Упомянутые авторы нашли решение проблем оптимизации в тонкой настройке взаимодействия с общей памятью в используемой архитектуре или применении адаптивных алгоритмов, способных динамически контролировать количество используемых потоков во время исполнения.

Анализируя представленные работы, можно прогнозировать зависимости между параметрами входных данных, выбранной архитектурой и ожидаемой производительностью используемой реализации обхода в ширину. Данное экспериментальное исследование посвящено выявлению таких зависимостей для алгоритма BFS, реализованного с применением методов линейной алгебры, что существенным образом влияет не только на сам алгоритм, но и на внутреннее представление графа в памяти компьютера.



\subsection{Обход в ширину в контексте линейной алгебры}
\noindent Для эффективного представления и манипулирования графовыми структурами можно использовать матрицы и вектора. Рассмотрим теоретические основы такой  абстракции и её преимущества.



\subsubsection*{GraphBlas}
\noindent Набор операций, который может быть применен к матрицам и векторам для выполнения различных графовых алгоритмов (таких как обходы, поиск путей, кластеризация и др.) заложен в \textit{GraphBlas}~\cite{gb_math}~\footnote{\href{https://graphblas.org/}{Форум, посвещенный стандарту GraphBlas. Дата посещения: \DTMdate{2023-05-23}}}.

Это инициитива, нацеленная на создание стандартизованного интерфейса для разработки графовых алгоритмов. Её целью является обеспечение высокой производительности и переносимости для широкого спектра решений, работающих с различными графовыми структурами.

Пользователю предоставляется спецификация, определяющая абстрактное умножение матрицы на вектор, сложение векторов и умножение матрицы на матрицу. Описанная семантика и требования для интерфейса позволяют создавать собственные реализации на различных языках программирования и для различных аппаратных платформ. 



\subsection{Представление графа в памяти компьютера}
\noindent Нужно отметить, что реальные графы сильно разреженны, но в то же время обладают сравнительно большим количеством вершин.
Плотность графа (англ. --- \textit{density}) можно вычислить по формуле: 
\begin{equation}
\label{eq:density}
	\text{density} = \frac{2 \cdot \big| E \big| }{\big| V \big| \cdot (\big| V \big| - 1)},
\end{equation}
где $\big| E \big|$ --- {количество рёбер}, а $\big| V \big|$ --- количество вершин.\linebreak
Разреженными можно считать графы со значением плотности $<$ 10$\%$. В то время как на практике в основном встречаются сильно разреженные графы со значением density $\ll$ $2\%$. 


Хранить такие данные в виде двумерных таблиц не является эффективным решением, поэтому используют специальные структуры. Рассмотрим некоторые из них.

\begin{itemize}
	\item{\textbf{Список смежности}} \newline
	Это один из наиболее простых и эффективных способов хранения разреженных графов. Для каждой вершины выделяется список ее соседей. Это может быть реализовано, к примеру, с помощью массива списков, где каждый индекс массива представляет вершину, а лежищай по выбранному индексу список содержит соседей этой вершины.
    \item{\textbf{Матрица смежности}} \newline 
    В матрице смежности каждый элемент указывает наличие или отсутствие ребра между двумя вершинами. В случае разреженных графов, где большая часть элементов матрицы будет нулевыми, может быть эффективно использована разреженная матрица, где хранятся только ненулевые значения.
    \item{\textbf{Список ребер}} \newline 
    Вместо хранения информации о соседних вершинах можно хранить список всех ребер графа. Каждое ребро тогда представляется парой вершин, которые оно соединяет. Этот подход эффективен для определенных операций, таких как перебор всех ребер.
    \item{\textbf{Компактные структуры данных}} \newline
    Например, CSR (\textit{Compressed Sparse Row}) и CSC (\textit{Compressed Sparse Column}), которые оптимизируют использование памяти для разреженных графов, сохраняя при помощи массивов информацию о вершинах, ребрах и их связях, и позволяют эффективно выполнять операции над разреженными графами.
\end{itemize}

\noindent Каждый метод имеет свои преимущества и недостатки с точки зрения памяти и производительности. Для сильно разреженных графов, которые были использованы для исследования BFS, в контексте линейной алгебры их представление лучше всего подходит в виде матрицы смежности. Более того, поскольку большинство значений у таких матриц равно нулю, для их хранения целесообрано использовать дополнительную структуру данных, абстракцией над которой выступают вектора и матрицы.



\subsection{Деревья квадрантов}
\noindent \textit{Деревья квадрантов (англ. --- Quadtree)} являются рекурсивной структурой данных, широко используемой для эффективного хранения и обработки разреженных матриц. Возможность представлять их компактным образом является ценным инструментом для оптимизации использования памяти.

Quadtree строится на основе деления матрицы смежности графа на четыре равные части (квадранта) и рекурсивного применения этого процесса деления ко всем четырем дочерним квадрантам. Каждый такой элемент может быть представлен в виде узла дерева, а в листьях хранится информация об объектах или данных, находящихся в соответствующем квадранте. Это позволяет эффективно представлять разреженные данные, так как области без объектов могут быть сохранены в упрощенной форме. 

Аналогично представлению матриц с помощью Quadtree, вектора можно хранить в виде двоичного дерева (\textit{англ. --- Binary tree}), применяя тот же принцип последовательного рекурсивного разделения. Представление векторов и матриц таким образом удобно не только для оптимизации памяти, но и для внедрения параллельных вычислений.

На рисунке~\ref{f:qtree1} представлена четверка узлов, образующих квадрант. Нумерацию и обозначение квадрантов принято вести слева направо, сверху вниз: (I)~NW~---~North-West, (II)~NE~---~North-East, (III)~SW~---~South-West, (IV)~SE~---~South-East.

\begin{center}
\begin{figure}[ht]
\centering
\begin{tikzpicture}
  \draw (-4,-3) rectangle (4,3);
  \draw (0,-3) -- (0,3);
  \draw (-4,0) -- (4,0);
  \node at (-2,1.5) {NW};
  \node at (2,1.5) {NE};
  \node at (-2,-1.5) {SW};
  \node at (2,-1.5) {SE};
\end{tikzpicture}
\end{figure}
\captionof{figure}{Квадратная матрица, разделенная на квадранты}
\label{f:qmatrix}
\end{center}

\begin{figure}[ht]
\Tree [.
[.
    [.NW [] ]
    [.NE [] ]
    [.SW [] ]
    [.SE [] ]]
  ]
\captionof{figure}{Схематичное изображение одного из узлов дерева квадрантов и его потомков}
\label{f:qtree1}
\end{figure}

На рисунке~\ref{f:qtree2} продемонстирована ситуация, в которой на некотором уровне квадрант имеет всего один значащий узел, остальные элементы матрицы являются незначащими (в нашем случае для них использовано обозначение \texttt{None}). Использование такого обозначения нулевых элементов обусловлено особенностями выбранного языка программирования, который будут рассмотрены далее.

\begin{figure}[ht]
\Tree [.{}
[.
    [.{}
        [.NW 
            [.{}
                [.None ]
                [.NE [] ]
                [.None ]
                [.SE [] ]
            ]
        ]
    ]
    [.None ]
    [.None ]
    [.None ]
]]
\captionof{figure}{Схематичное изображение нескольких уровней дерева с отсутствующими значениями в некоторых узлах}
\label{f:qtree2}
\end{figure}



\subsection{Языковые особенности \fsharp}
\noindent \texttt{Option} --- это тип-контейнер, который может либо содержать значение определенного типа, либо быть пустым \texttt{(None)}. Такое представление незначащих элементов очень удобно по нескольким причинам.
\begin{itemize}
\item{\textbf{Естественное выражение отсутствия значения}} \newline
Деревья квадрантов могут иметь узлы, которые не содержат никаких данных или не имеют потомков. Использование типа \texttt{Option}позволяет явно на это указать, делая код более читабельным.
\item{\textbf{Спосотавление по образцу (англ. --- pattern-matching)}} \newline
Эта особенность языка позволяет легко обрабатывать различные случаи, встречающиеся в узлах деревьев.
\item{\textbf{Безопасность типов}} \newline
Использование \texttt{Option} обеспечивает статическую проверку типов. Например, компилятор предотвратит ошибки, связанные с попыткой обращения к значению там, где его нет.
\end{itemize}

%\noindent Кроме того, \texttt{F\#} --- %преимущественно \textit{функциональный язык} %программирования, что делает обработку рекурсивных %структур, которыми являются деревья, более простой.

Необходимо также затронуть такую особенность, использовавшуюся при реализации параллельной версии BFS, как \textit{асинхронные} вычисления. Это подход к обработке данных, при котором задачи выполняются независимо друг от друга и без явной синхронизации. Вместо того чтобы ждать завершения одной задачи (англ. --- Task) до перехода к следующей, асинхронные методы позволяют запускать несколько задач одновременно на разных потоках и обрабатывать результаты по мере их готовности. В \fsharp такой метод вызывается с помощью ключевого слова \texttt{async}, в то время как тип \texttt{Async<'T>} представляет асинхронную операцию.