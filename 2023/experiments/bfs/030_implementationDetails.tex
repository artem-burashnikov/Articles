% !TeX spellcheck = ru_RU
% !TEX root = artem-burashnikov_parallel_bfs_experiments.tex

\section{Детали реализации}
В этом разделе будут продемонстрированы шаги обхода в ширину с применением матрично-векторных операций и представлен пример алгоритма на языке \texttt{F\#} с применение параллельных вычислений.



\subsection{Концепция алгоритма}
Применение операции умножения вектора на матрицу, определенной в GraphBlas, является переходом от одних вершин графа к другим по инцидентным этим вершинам рёбрам.
Как упоминалось выше, векторы представлены в виде Binary tree, а матрицы --- в виде Quadtree. Рассмотрим конкретные шаги обхода в ширину в контексте линейной алгебры.
\begin{itemize}
    \item{\textbf{Шаг 1}} \newline Создается матрица смежности (\textit{англ. --- adjacency matrix}), соответствующая данному графу. В нашем случае по матрице смежности, представленной как список координат, строится дерево квадрантов. Значения в ячейках матрицы заполняются значениями на соответствующих рёбрах графа.
    \item{\textbf{Шаг 2}} \newline Задаются два вектора.
    \begin{enumerate}
        \item{\textbf{Фронт (\textit{англ. --- front})}} \newline Вектор, в котором каждый индекс соответствует вершине графа, а значения указывают на текущие просматриваемые вершины.
        \item{\textbf{Результирующий вектор}} \newline 
        При инициализации совпадает с фронтом а в процессе работы алгоритма аккумулирует промежуточные результаты (например, длину минимального пути).
    \end{enumerate}
    \item{\textbf{Шаг 3}} \newline Выполняется умножение вектора состояний на матрицу смежности. В качестве поэлементных операций сложения и умножения используются логические \texttt{ИЛИ} и \texttt{И}. После каждого умножения на результирующий вектор применяется маска (\textit{англ. --- mask}), чтобы алгоритм не обрабатывал уже посещенные вершины. Результатом итерации является новый фронт и обновленный результирующий вектор.
\end{itemize}

Шаг 3 повторяется до тех пор, пока не будут достигнуты требуемые условия остановки. Например, все вершины станут исследованы или произойдет выполнение определенного условия.



\subsection{Параллельные вычисления}
Благодаря рекуррентной природе деревьев, являющихся в нашем случае внутренним представлением векторов и матриц, реализованный алгоритм естественным образом позволяет внедрить дополнительные потоки процессора. В листинге~\ref{alg:bfs_example} представлен псевдокод с использованием абстрактных операций линейной алгебры. \textit{Минимальными единицами} такой операции являются вектор размера \texttt{1$\times$2} и матрица размера \texttt{2$\times$2}, что на каждой итерации позволяет использовать до четырех дополнительных потоков для разделения вычислений между ними. Рисунок~\ref{ab_product} демонстрирует операции, необходимые для вычисление результирующего вектора при перемножении минимальных единиц. 

\begin{figure}[h]
\begin{center}
    \begin{tabular}{ccc}
        $\begin{bmatrix} a_{11} & a_{12} \end{bmatrix}$
        $\times$
        $\begin{bmatrix} b_{11} & b_{12} \\ b_{21} & b_{22} \end{bmatrix}$
        =
        $\begin{bmatrix} a_{11} \times b_{11} + a_{12} \times b_{21} \\ a_{11} \times b_{12} + a_{12} \times b_{22} \end{bmatrix}$
    \end{tabular}
\end{center}
\caption{Элементарная операция умножения вектора на матрицу}
\label{ab_product}
\end{figure}
\lstset{style=codelistingstyle}

\begin{algorithm}[h]
\floatname{algorithm}{Листинг}
\caption{Псевдокод параллельного алгоритма обхода в ширину c использованием методов линейной алгебры}
\label{alg:bfs_example}
\begin{lstlisting}[language=pseudoFSharp]
let BFS parallelLevel startingVertices graph =

	let adjacencyMatrix = graph.AdjMtx

    let frontier = SparseVector startingVertices

    let result = SparseVector startingVertices

    let rec inner frontier visited counter =

        if frontier.IsEmpty then
            result
        else

            let newFrontier =
                MatrixAlgebra.vecByMtx parallelLevel frontier adjacencyMatrix
                |> SparseVector.Map2 parallelLevel fMask result

            let newResult =
                SparseVector.Map2 parallelLevel (fUpdateCount counter) result newFrontier

            inner newFrontier newResult (counter + 1u)

    inner frontier result 1u
\end{lstlisting}
\end{algorithm}

Элементы матрицы --- поддеревья, поэтому вычисление элемента $a_{is} \times b_{sj}$ является рекурсивным вызовом на соответствующем поддереве. В представленной работе операция умножения над \textit{минимальными единицами} разбивается на два потока: один из потоков отвечает за вычисление значения в первой строке результирующего вектора, а другой поток --- за вычисление во второй. При необходимости увеличить глубину параллелизации на вход в BFS передаётся целый положительный параметр \textit{parallelLevel}, величина которого уменьшается с каждым вызовом тела функции, в результате чего производятся дополнительные асинхронные вычисления на следующем уровне рекурсии. При значении параметра равным 0 выполняется последовательная версия BFS.

Дополнительные детали алгоритма можно найти в репозитории~\footnote{\href{https://github.com/artem-burashnikov}{Репозиторий с реализацией BFS в контексте линейной алгебры. Дата посещения: \DTMdate{2023-05-23}}}.